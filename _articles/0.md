---
id: 0
title: "Formally proving left-pad in ATS"
subtitle: "Or, how to spend a weekend bashing your head on your keyboard"
date: "2024.01.17"
tags: "ATS, formal-methods"
---

I've been learning the ATS language for the past week. For the uninitiated, ATS is a language boasting a horrible yet interesting 
mixture of functional programming, systems programming, and formal verification in a single language. Using linear logic and
the theorem-proving capabilities of LF[^1], ATS is capable of verifying the correctness of functions automatically[^2] while
retaining all of the flexibility and low-level access of C.

Despite everything, I've actually enjoyed using it thus far. The language looks like a horrible jumbled mess from the outset, but
as my first introduction to dependent types, linear logic, and formal verification, I find the language to be (dare I say) surprisingly elegant.

Well, apart from the lack of documentation and terrible error messages that is[^3]. Once you get past both hurdles, though, it feels
like the culmination of many disparate areas of programming working in tandem.

Let's start with a very simple example of theorem proving in this language. We want a function that takes a number n and returns
n + 1:
```
// Take n and return n + 1
fn plus_one (n: int) : int = n + 1
```
The syntax looks familiar to anyone who has use a variant of ML before. However, it doesn't contain any proof of its correctness.
I could just as easily replace n + 1 with n + 2 and the compiler wouldn't complain because it has no idea what this function is
trying to accomplish.

If we want the compiler to verify the correctness of this function, it's as simple as adding a dependent type:
```
// Take n and return n + 1
fn plus_one {x: int} (n: int x) : int (x + 1) = n + 1
```
The parameter `x` tells the compiler that the output should be equal to the run-time value of `n` plus one.

Simple, right? Now let's say we want to take a pointer and increment the integer at its location by one. The first iteration
might look something like this:
```
fn plus_one {l: addr} (pf: int @ l | p: ptr l) : (int @ l | ptr l) =
    (pf | p) where {
        val n = ptr_get<int>(pf | p)
        val () = ptr_set<int>(pf | p, n)
    }
```
`pf` is a proof that there is an integer at (@) address `l`, the location of our pointer `p` (since 
the type of `p` is parametrized on address `l`). You can see that whenever we dereference the pointer,
we need to pass this proof. This ensures every pointer dereference is safe!

Using some special syntax, we can shorten it to:
```
fn plus_one {l: addr} (pf: int @ l | p: ptr l) : (int @ l | ptr l) =
    (pf | p) where {
        val n = !p
        val () = !p := n + 1
    }
```
Whenever `!p` is used where `p` is a type `ptr l`, the compiler searches for a suitable proof `T @ l` and
deduces the type `T` of the dereferenced variable. In this case, `pf` matches and it yields an int. You can
think of every `ptr` type being a `void*` in C, while all the type information comes from these proofs.

We can prove its correctness using a dependent type again:
```
fn plus_one {l: agz}{x: int} (pf: int(x) @ l | p: ptr l) : (int(x + 1) @ l | ptr l) =
    (pf | p) where {
        val n = !p
        val () = !p := n + 1
    }
```

And we can also omit the need to return the proof and pointer again like this:

```
fn plus_one {l: agz}{x: int} (pf: !(int(x) @ l) >> int(x + 1) @ l | p: ptr l) : void =
    () where {
        val n = !p
        val () = !p := n + 1
    }
```

When this code is compiled, ATS transpiles it to C (the rest of the work is done by a C compiler). ATS ensures
type erasure for all "proof" variables, meaning this function should be just as fast as if we wrote it in C like so:
```C
void plus_one(void* p) {
    int n = *(int*)(p);
    *(int*)(p) = n;
}
```
But this C function is very unsafe! Of course, this is a trivial example, but if one wants to ensure a more complicated
function never breaks, C lacks this capabilitC lacks this capabilityy.

Ok, one more example. Let's say 




[^1]: http://twelf.org/wiki/LF
[^2]: Automatic in the sense that it will verify if your proof makes sense using its SMT solver. You're on your own for everything else.
[^3]: The error messages manage to surpass C++ in their unhelpfulness. No, compiler, I don't know what S2Eapp(S2Ecst(str_v); S2Evar(l(8518)), ...)) means.
